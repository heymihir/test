ydef extract_date_from_column(col_name):
    """
    Extracts the last 10 characters from col_name, strips whitespace,
    and attempts to parse as a date. Returns None if parsing fails.
    """
    # Grab last 10 characters (this will include a leading space if month < 10)
    date_str = col_name[-10:].strip()
    try:
        # Let pandas infer the date format (handles zero-padded or single-digit months)
        return pd.to_datetime(date_str, infer_datetime_format=True)
    except ValueError:
        # If it cannot parse, return None
        return None

# Build a list of (col_name, parsed_date) tuples, filtering out anything that doesn't parse
parsed = []
for col in columns:
    dt = extract_date_from_column(col)
    if dt is not None:
        parsed.append((col, dt))

# Sort by date
parsed.sort(key=lambda x: x[1])  # Sort ascending by the parsed date

# We want the second-largest date => second from the end
# Make sure we have at least 2 valid dates
if len(parsed) >= 2:
    second_largest_col = parsed[-2][0]  # the column name of the second-latest date
    print("Second largest date column:", second_largest_col)
else:
    print("Not enough valid date columns to determine second-largest date.")
